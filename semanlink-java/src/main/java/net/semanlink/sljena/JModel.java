package net.semanlink.sljena;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;

import org.apache.jena.rdf.model.Literal;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.rdf.model.NodeIterator;
import org.apache.jena.rdf.model.Property;
import org.apache.jena.rdf.model.RDFNode;
import org.apache.jena.rdf.model.ResIterator;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.rdf.model.Statement;
import org.apache.jena.rdf.model.StmtIterator;
import org.apache.jena.shared.JenaException;
import org.apache.jena.vocabulary.RDF;

import net.semanlink.metadataextraction.MetadataExtractorManager;
import net.semanlink.semanlink.DocsFile;
import net.semanlink.semanlink.SLDocument;
import net.semanlink.semanlink.SLKeyword;
import net.semanlink.semanlink.SLModel;
import net.semanlink.semanlink.SLRuntimeException;
import net.semanlink.semanlink.SLThesaurus;
import net.semanlink.semanlink.SLUtils;
import net.semanlink.semanlink.SLVocab;
import net.semanlink.semanlink.SLDocUpdate;
import net.semanlink.servlet.SLServlet;
import net.semanlink.skos.SKOS;
import net.semanlink.sljena.modelcorrections.AliasCorrection;
import net.semanlink.sljena.modelcorrections.BadFileUrisCorrection;
import net.semanlink.sljena.modelcorrections.KeywordUriCorrection;
import net.semanlink.sljena.modelcorrections.ModelCorrector;
import net.semanlink.util.Util;
import net.semanlink.util.YearMonthDay;
/*
 * TODO
 * setKwProperty et setDocProperty ne sont pas faits pareils. doc semble zarbi
 * (2 methodes de quasi meme signature)
 * setKwProperty : un avec SLKeyword, lm'autre kwuri en 1er arg. Le 1 er def par le 2eme. Ceci pourrait 
 * e^re fait ds SLModel. Faut-il les 2 ? Y-a-t-il vraiment besoin de chercher kw ds action ?
 * Combien de foi?s fait-on cette recherche
 * TOUT CA A VERIFIER
 */
/**
 * Le "modèle" Semanlink.
 * <B>Au sujet des fonctions getResources() et createResources de Model</B>
 * Il y a un problème : getResource retourne toujours (? du moins avec ModelMem) une Resource,
 * alors qu'on s'attendrait ? ce qu'elle retourne null si la Resource n'est pas présente dans le Model.
 * Et c'est très génant du coup de ne pas pouvoir le savoir
 * (d'autant que la javadoc dit de n'utiliser getResource que si la Resource existe dans le Model.
 * A mon avis, ils ont merdé sur ce coup l?.
 * Du coup, je suis obligé, l? o? j'espérais pouvoir utiliser getResource puis tester son retour
 * (vis ? vis de null) de systématiquement faire un CreateResource.
 *
 *
 *ATTENTION : IL FAUT ECRIRE LA DATE DE CREATION EN PREMIER - ET LA SUPPRIMER EN DERNIER DS LES DESTRUCTIONS
 * Gestion de l'écriture : POUR LES DOCS SEULEMENT faite à chaque ajout au model, 
 * qui est surveillé par un listener // FAUX !!! FALSE
 * 
 * Writing changes management: for documents only, there is a listener that watchs the statements added to the model.
 * 
 * There is a difficulty when removing all the statements about a doc, to write the change:
 * the file used to store statements about a doc may be defined by the creation date
 * of the doc (it is the case, at least, for bookmarks). When removing all the statements about a doc,
 * we must take care of that: we could remove the statement about the creation date, and then we would no more
 * be able to write the other changes. This prevent us from using the listener listening to changes
 * of this.getDocsModel() to do the save.
 * -> removing a doc must take care by itself of saving the changes to the model
 * -> we cannot use the listener to remove statements (or we would try to write the changes twice when deleting a doc)
 * CONCLUSION :
 * - to add statements to doc, we use the listener to save the changes
 * - when removing statement, we must handle the save
 */
import net.semanlink.util.index.MultiLabelGetter;
public class JModel extends SLModel {

	
/** We should take care of any string passed to the application and that can be returned back in HTML
 *  (cf XSS attack)
 *  With Jena until 2.4, we should also take care of problems in XML generated by RDFWriter, that
 *  can be illegal if a statement contain some control characters that are illegal in XML
 *  (and also some char sequences)
 *  We just do here a quick hack, removing some of these char sequences when
 *  adding a statement whose property is a literal. */
String safe(String s) {
	if (s == null) return null;
	s = s.replaceAll("<script", "&lt;script");
	// following line no more needed with jena 2.5
	// s = s.replaceAll("]]>", "]]&gt;");
	// this is till needed with jena 2.5 (no more risk of corrupted xml files,
	// but risk of an exception)
	return Util.removeIllegalXMLChars(s);
}


	
//
// VOCABULAIRE (pour interface ?)
//
private Resource keywordClass;
private Property hasKeywordProperty;
private Property hasParentProperty;
private Property hasFriendProperty;
private Property commentProperty;
private Property slCreationDateProperty;
Property sourceProperty;
private Property hasAliasProperty;
private Property mainDocProperty;

// Resource noKeywordRes;
// JKeyword noKeyword;
private void initStandardTerms() {
  try {
    this.keywordClass = this.kwsModel.getResource(KEYWORD_CLASS);
    this.hasKeywordProperty = this.docsModel.getProperty(HAS_KEYWORD_PROPERTY);
    this.hasParentProperty = this.kwsModel.getProperty(HAS_PARENT_PROPERTY);
    this.hasFriendProperty = this.kwsModel.getProperty(HAS_FRIEND_PROPERTY);
    this.commentProperty = this.docsModel.getProperty(COMMENT_PROPERTY);
    this.slCreationDateProperty = this.docsModel.getProperty(SL_CREATION_DATE_PROPERTY);
    this.sourceProperty = this.docsModel.getProperty(SOURCE_PROPERTY);
    this.hasAliasProperty = this.kwsModel.getProperty(HAS_ALIAS_PROPERTY);
    // this.noKeywordRes = createKWRes(urlVocabulaire() + "nokeyword", "(No JKeyword)");
	// this.noKeywordRes = JenaUtils.newKeyword(this.docsModel, urlVocabulaire() + "nokeyword", "(No Keyword)", null);
    // this.noKeyword = new JKeyword(this, noKeywordRes);
    this.mainDocProperty = this.docsModel.getProperty(SL_MAIN_DOC_PROPERTY);
  } catch (Exception e) {throw new SLRuntimeException(e);}
}

//
// IMPLEMENTATION au dessus de JENA
//

private Model kwsModel;
private Model docsModel;

/** if not null, its corrections are applied to files at the time they are loaded. 
 * Typically set at the beginning of the loading of SemanlinkConfig, and reset to null at the end. */
private ModelCorrector modelCorrector;
// private DocListener docListener;
// private KwListener kwListener;

public JModel() {
  try {
    this.kwsModel = ModelFactory.createDefaultModel();
    this.docsModel = ModelFactory.createDefaultModel();
    // init d'attributs "quasi-statiques"
    initStandardTerms();
  } catch (Exception ex) {throw new SLRuntimeException(ex);}
}

public Model getDocsModel() { return this.docsModel; }
public Model getKWsModel() { return this.kwsModel; }
//
public void setCorrector(ModelCorrector corrector) {
	this.modelCorrector = corrector;
	if (corrector == null) {
		this.modelCorrector = new ModelCorrector();
	}
	modelCorrector.add(new BadFileUrisCorrection(this));		
}

private JKwLabelGetter kwLabelGetter; // use getter
@Override public MultiLabelGetter<SLKeyword> getKwLabelGetter() { // 2020-04
	if (kwLabelGetter == null) {
		kwLabelGetter = new JKwLabelGetter();
	}
	return kwLabelGetter;
}
	
//
// GETTING / CREATING A DOCUMENT
//

public SLDocument getDocument(String uri) {
	Resource res = this.docsModel.getResource(uri);
	return new JDocument(this, res);
}

/** Retourne true ssi doc intervient dans au moins un statement en tant que sujet. */
public boolean existsAsSubject(SLDocument doc) {
	Resource res = ((JDocument) doc).getRes();
	StmtIterator ite = res.listProperties ();
	for (;ite.hasNext();) {
		ite.close();
		return true;
	}
	ite.close();
	return false;
}

public boolean hasSLCreationDate(SLDocument doc) {
	Resource res = ((JDocument) doc).getRes();
	StmtIterator ite = res.listProperties(slCreationDateProperty);
	for (;ite.hasNext();) {
		ite.close();
		return true;
	}
	ite.close();
	return false;
}




/**
 * attention, ajout rapide en 2003-07-01 pour servlet
 */
public SLKeyword getKeyword(String uri) throws JenaException {
	return new JKeyword(this, this.kwsModel.getResource(uri));
}

//
// ALIAS
//

/** suppose qu'on a qu'un seul niveau (pas d'alias d'alias).
 *  Si uri est alias de plusieurs res (ce qui ne devrait pas), prend le 1er trouvé
 */
public String resolveAliasAsUri(String uri) {
	return resolveAliasAsResource(uri).getURI();
}

/** suppose qu'on n'a qu'un seul niveau (pas d'alias d'alias).
 *  Si uri est alias de plusieurs res (ce qui ne devrait pas), prend le 1er trouvé
 */
public SLKeyword resolveAlias(String uri) {
	return new JKeyword(this, resolveAliasAsResource(uri));
}

/** suppose qu'on a qu'un seul niveau (pas d'alias d'alias).
 *  Si uri est alias de plusieurs res (ce qui ne devrait pas), prend le 1er trouvé
 */
private Resource resolveAliasAsResource(String uri) {
	Resource res = this.kwsModel.getResource(uri);
	ResIterator ite = this.kwsModel.listSubjectsWithProperty(hasAliasProperty, res);
	if (ite.hasNext()) {
		// uri est un alias
		res = ite.nextResource();
	}
	ite.close();
	return res;
}

/** liste de toutes les uris d'alias (sous forme de Strings). */
public void aliasesIntoCollectionOfUris(Collection coll) throws JenaException {
	NodeIterator ite = this.kwsModel.listObjectsOfProperty(this.hasAliasProperty);
    for (;ite.hasNext();) {
			Resource node = (Resource) ite.next();
			coll.add(node.getURI());
    }
    ite.close();
}

/** remplace les "hasKeyword" des documents, et transfère fils et parents.
 */
// public void aliasIt(String aliasUri, String kwUri) {
public void aliasIt(SLKeyword alias, SLKeyword kw) {
	try {
		//SLKeyword alias = this.getKeyword(aliasUri);
		//SLKeyword kw = this.getKeyword(kwUri);
		// transfert des docs
		List al = alias.getDocuments();
		for (int i = 0; i < al.size() ; i++) {
			SLDocument doc = (SLDocument) al.get(i);
			String docUri = doc.getURI();
			// JenaUtils.remove(getDocsModel(), docUri, this.HAS_KEYWORD_PROPERTY, alias.getURI());
			// JenaUtils.add(getDocsModel(), docUri, this.HAS_KEYWORD_PROPERTY, kw.getURI());
			JFileBiModel bi2 = this.getJFileBiModel4Docs(docUri);
			bi2.remove(docUri, this.HAS_KEYWORD_PROPERTY, alias.getURI());
			bi2.add(docUri, this.HAS_KEYWORD_PROPERTY, kw.getURI());
			bi2.save();
		}
		
		/* B4 2012-12
		// transfert des parents
		al = alias.getParents();
		SLKeyword[] kws = new SLKeyword[al.size()];
		al.toArray(kws);
		for (int i = 0; i < kws.length ; i++) {
			this.addParent(kw, kws[i]);
		}
		this.removeParents(alias, kws);
		
		// transfert des enfants
		al = alias.getChildren();
		kws = new SLKeyword[al.size()];
		al.toArray(kws);
		for (int i = 0; i < kws.length ; i++) {
			this.addChild(kw, kws[i]);
		}
		this.removeChildren(alias, kws);

		// transfert des amis
		al = alias.getFriends();
		kws = new SLKeyword[al.size()];
		al.toArray(kws);
		for (int i = 0; i < kws.length ; i++) {
			this.addFriend(kw, kws[i]);
		}
		this.removeFriends(alias, kws);

		// si alias était un kw à part entière, virer son type
		this.removeKWStatement(alias.getURI(), RDF.type.getURI(), KEYWORD_CLASS);
		*/
		
		// @find SKOSIFY 2012-12
		// transfert de toutes les props de l'alias vers l'original
		// Pour ce qui est de l'indexation texte,
		// la refaire en sortie pour le kw orginal
		

		Model m = this.kwsModel;
		Resource originalRes = m.createResource(kw.getURI());
		Resource aliasRes = m.createResource(alias.getURI());
		
		ArrayList<Statement> newStas = new ArrayList<Statement>(); // pour être sûr d'éviter les embrouilles
		StmtIterator sit = m.listStatements(aliasRes, (Property) null, (RDFNode) null);
		for (;sit.hasNext();) {
			Statement oldSta = sit.next();
			// attention au prefLabel (et qlqs autres props ?)
			Property p = oldSta.getPredicate();
			if (p.equals(SKOS.prefLabel)) {
				p = SKOS.altLabel;
			/* } else if (p.equals(SL_CREATION_DATE_PROPERTY)) {
				continue;
			} else if (p.equals(SL_CREATION_DATE_PROPERTY)) {
				continue; */
			}
			newStas.add(m.createStatement(originalRes, p, oldSta.getObject()));
		}
		// now remove olds
		sit = m.listStatements(aliasRes, (Property) null, (RDFNode) null);
		m.remove(sit);
		
		sit = m.listStatements((Resource) null, (Property) null, aliasRes);
		for (;sit.hasNext();) {
			Statement oldSta = sit.next();
			newStas.add(m.createStatement(oldSta.getSubject(), oldSta.getPredicate(), originalRes));
		}
		// now remove olds
		sit = m.listStatements((Resource) null, (Property) null, aliasRes);
		m.remove(sit);
		
		// and add new
		m.add(newStas);
		
		// remet d'équerre les date de création
		updateDate(m, originalRes, m.createProperty(SL_CREATION_DATE_PROPERTY));
		updateDate(m, originalRes, m.createProperty(SL_CREATION_TIME_PROPERTY));
		
		
		// save // HACK INCORRECT TODO
		SLThesaurus th = kwUri2Thesaurus(originalRes.getURI());
		if (th == null) throw new IllegalArgumentException("No opened thesaurus for " + originalRes.getURI());
		SLThesaurus thalias = kwUri2Thesaurus(alias.getURI());
		if (thalias == null) throw new IllegalArgumentException("No opened thesaurus for " + alias.getURI());
		if (!thalias.equals(th)) throw new UnsupportedOperationException();
		JFileModel smallJFileModel = new JFileModel(this.kwsModel,th.getDefaultFile(), th.getBase()); // HACK NOT GOOD
		smallJFileModel.save();
		
	} catch (Exception e) { throw new SLRuntimeException(e); }	
}

/** ne garde que la plus ancienne des dates */
private void updateDate(Model m, Resource kwRes, Property dateProp) {
	String oldest = null;
	NodeIterator it = m.listObjectsOfProperty(kwRes, dateProp);
	boolean change = false;
	for (;it.hasNext();) {
		String d = it.next().asLiteral().getString();
		if (oldest == null) { 
			oldest = d;
		} else {
			change = true;
			if (d.compareTo(oldest) < 0) oldest = d;
		}
	}
	if (change) {
		StmtIterator sit2 = m.listStatements(kwRes, dateProp,(RDFNode) null);
		m.remove(sit2);
		m.add(kwRes,dateProp,oldest);
	}
}

//
// LOADING SL FILES
//

/** 
 * Charge le fichier de documents slFile en considerant les uri, qui y sont exprimees sous forme courte,
 * relatives a base
 * @param base l'uri utilisee pour convertir les uri relatives en uri absolues. (Doit donc
 * respecter la syntaxe correcte pour les uri, en particulier pour ce qui concerne les caracteres admissibles.)
 * Typiquement, dans un fonctionnement local (urls de protocole file), base est l'uri de slFile
 * (ou plutot, pour cause d'un probleme avec base dans Jena, l'uri, "/" terminated, du dossier
 * qui le contient)
 */
protected void readDocsModelFromFile(String slFile, String base) throws JenaException, IOException {
	if (this.modelCorrector != null) {
		try {
			this.modelCorrector.correctDocsModel(slFile, base);
		} catch (Exception e) {
			// ne pas empecher la lecture si erreur ds modelCorrector
			// (rappel - voir JFileModel : si on tente d'ecrire une bad uri,
			// exception - mais on reprend le fichier de backup.)
			System.err.println("JModel.readDocsModelFromFile Exception caught : " + e);		
		}
	} 
	ModelFileIOManager.getInstance().readModel(this.docsModel, slFile, base);
}

//@find changing uris
protected void readKWsModelFromFile(String slFile, String base) throws MalformedURLException, IOException, JenaException, URISyntaxException {
	if (this.modelCorrector != null) this.modelCorrector.correctKwsModel(slFile, base);
	// ModelFileIOManager.getInstance().readModel(this.kwsModel, slFile, null);
	ModelFileIOManager.getInstance().readModel(this.kwsModel, slFile, base);
}

//
// EDIT MODEL
//

// Remove links

/** Supprimer l'affectation d'un kw a un doc. */ // 2020-03 TODO
public void removeKeywords(SLDocument doc, SLKeyword[] kws) {
	try {
		String docUri = doc.getURI();
		JFileBiModel bi = getJFileBiModel4Docs(docUri);
		for (int i = 0; i < kws.length; i++) {
			bi.remove(docUri, HAS_KEYWORD_PROPERTY, kws[i].getURI());
		}
		bi.save();
	} catch (Exception e) { throw new SLRuntimeException(e); }
}

//	 EDITING KEYWORDS

public void removeParents(SLKeyword kw, SLKeyword[] parents) {
	if (parents.length == 0) return;
	try {
		String kwUri = kw.getURI();
		JFileBiModel bi = getJFileBiModel4Kws(kwUri);
		for (int i = 0; i < parents.length; i++) {
			bi.remove(kwUri, HAS_PARENT_PROPERTY, parents[i].getURI());
		}
		bi.save();
	} catch (Exception e) { throw new SLRuntimeException(e); }	
}

public void removeChildren(SLKeyword kw, SLKeyword[] children) {
	if (children.length == 0) return;
	try {
		JFileBiModel bi, biToBeSaved=null; // biToBeSaved : pour ne pas faire de multiple save si c'est toujours le même fichier
		String kwUri = kw.getURI();
		for (int i = 0; i < children.length; i++) {
			bi = getJFileBiModel4Kws(kw.getURI());
			if (!bi.equals(biToBeSaved)) {
				if (biToBeSaved != null) biToBeSaved.save();
			}
			bi.remove(children[i].getURI(), HAS_PARENT_PROPERTY, kwUri);
			biToBeSaved = bi;
		}
		if (biToBeSaved != null) biToBeSaved.save();
	} catch (Exception e) { throw new SLRuntimeException(e); }	
}

/** friends is symetric. This is handled here */
public void removeFriends(SLKeyword kw, SLKeyword[] removed) {
	if (removed.length == 0) return;
	String kwUri = kw.getURI();
	
	try {
		JFileBiModel bi, biToBeSaved; // biToBeSaved : pour ne pas faire de multiple save si c'est toujours le même fichier
		bi = getJFileBiModel4Kws(kw.getURI());
		for (int i = 0; i < removed.length; i++) {
			bi.remove(kwUri, HAS_FRIEND_PROPERTY, removed[i].getURI());
		}
		biToBeSaved = bi;
		// bi.save();

		for (int i = 0; i < removed.length; i++) {
			bi = getJFileBiModel4Kws(removed[i].getURI());
			if (!bi.equals(biToBeSaved)) {
				biToBeSaved.save();
			}
			bi.remove(removed[i].getURI(), HAS_FRIEND_PROPERTY, kwUri);
			// bi.save();
			biToBeSaved = bi;
		}
		if (biToBeSaved != null) biToBeSaved.save();
	} catch (Exception e) { throw new SLRuntimeException(e); }	
}

///** returns true if, when adding a statement about doc and with predicate addedPropUri,
// *  doc must be considered a new doc (and we have therefore to set its creation date)
// */
//private boolean needsToSendANewDocEvent(SLDocument doc, String addedPropUri) {
//	if (existsAsSubject(doc)) return false;
//	// we don't want a local copy of a doc to be considered a doc (with properties such as
//	// creation data etc.), hence the test on statement's predicate (a local copy
//	// has its source prop pointing to the actual document) (If the subject is a real doc,
//	// it will have others props set: we won't miss to send the addedDoc event)
//	// (Note : we do not need the creation date to find the file of a local copy and so being able
//	// to add statement to it : it's a local copy - its uri tells where it is stored!)
//	if (addedPropUri.equals(SLVocab.SOURCE_PROPERTY)) return false;
//	return true;
//}
//
////** propertyUri must NOT be SL_CREATION_DATE_PROP */
//private JFileBiModel getJFileBiModel4DocsHandlingNewDocEvent(SLDocument doc, String propertyUri) throws IOException, URISyntaxException {
//	boolean newDocEvent = needsToSendANewDocEvent(doc, propertyUri);
//	String today = null;
//	if (newDocEvent) {
//		// it's better to set the SL_CREATION_DATE first,
//		// in order to choose the right file to write new doc to
//		// (cf case where propertyUri is SL-CREATION_DATE: this happens with import from delicious:
//		// we want to set the creation date (which has to be the first prop to be set for the doc)
//		today = (new YearMonthDay()).getYearMonthDay("-");
//		JenaUtils.add(this.docsModel, doc.getURI(), SL_CREATION_DATE_PROPERTY, today, null);
//	}
//	JFileModel smallJFileModel = getJFileModel4Docs(doc.getURI());
//	JFileBiModel bi = new JFileBiModel(this.docsModel, smallJFileModel);
//	if (newDocEvent) {
//		JenaUtils.add(smallJFileModel.getModel(), doc.getURI(), SL_CREATION_DATE_PROPERTY, today, null);
//		moreOnDocCreation(doc.getURI(), bi);
//	}
//	return bi;
//}
//// autres trucs à faire au on new doc (à part la sl creation date). 
//private void moreOnDocCreation(String docUri, JFileBiModel bi) throws IOException, URISyntaxException {
//	bi.add(docUri, SL_CREATION_TIME_PROPERTY,(new YearMonthDay()).getTimeString(), null);
//	if (SLVocab.DATE_PARUTION_PROPERTY.equals(SLServlet.getDefaultSortProperty())) { // 2019-09 for sicg
//		String today = (new YearMonthDay()).getYearMonthDay("-");
//    bi.add(docUri, DATE_PARUTION_PROPERTY, today, null);		
//	} else {
//		//
//		File file = getFile(docUri);
//		YearMonthDay modifDay = null;
//		if (file != null) {
//			if (file.exists()) {
//				long lastModified = file.lastModified();
//				// peut s'optimiser en testant sur la date plutôt que sa représentation en string
//				modifDay = new YearMonthDay(new Date(lastModified));
//				String modifVal = modifDay.getYearMonthDay("-");
//				// if (modifVal.compareTo("2005-11-01") > 0) {
//				    bi.add(docUri, DATE_PARUTION_PROPERTY, modifVal, null); // 2020-03 TODO CHECK
//				// }
//			}
//		}
//	}
//}

// 2020-03

//public void addDocProperty(SLDocument doc, String propertyUri, String propertyValue, String lang) {
////	propertyValue = safe(propertyValue);
////	lang = safe(lang);
////	String docUri = doc.getURI();
////	if ((propertyValue != null) && (!("".equals(propertyValue)))) {
////		try {			
////			if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) {
////				creationDateCase(doc, propertyValue);
////				return;
////			}
////			JFileBiModel bi = getJFileBiModel4DocsHandlingNewDocEvent(doc, propertyUri);
////			bi.add(docUri, propertyUri, propertyValue, lang);
////			bi.save();
////		} catch (Exception e) { throw new SLRuntimeException(e); }
////	}
//	try (JDocUpdate du = new JDocUpdate(this, doc)) {
//		du.addDocProperty(propertyUri, propertyValue, lang);
//	} catch (Exception e) { throw new SLRuntimeException(e); }
//}

//public void addDocProperty(SLDocument doc, String propertyUri, String objectUri) {
////	String docUri = doc.getURI();
////	if ((objectUri != null) && (!("".equals(objectUri)))) {
////		try {
////			if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) throw new IllegalArgumentException("Impossible way to modify " + SLVocab.SL_CREATION_DATE_PROPERTY);
////			JFileBiModel bi = getJFileBiModel4DocsHandlingNewDocEvent(doc, propertyUri);
////			bi.add(docUri, propertyUri, objectUri);
////			bi.save();
////		} catch (Exception e) { throw new SLRuntimeException(e); }
////	}
//	try (JDocUpdate du = new JDocUpdate(this, doc)) {
//		du.addDocProperty(propertyUri, objectUri);
//	} catch (Exception e) { throw new SLRuntimeException(e); }
//}

//public void addDocProperty(SLDocument doc, String propertyUri, String[] objectUris) {
////	String docUri = doc.getURI();
////	if (objectUris != null) {
////		try {
////			if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) throw new IllegalArgumentException("Impossible way to modify " + SLVocab.SL_CREATION_DATE_PROPERTY);
////			JFileBiModel bi = getJFileBiModel4DocsHandlingNewDocEvent(doc, propertyUri);
////			for (int i = 0; i < objectUris.length;i++) {
////				String objectUri = objectUris[i];
////				if ((objectUri != null) && (!("".equals(objectUri)))) {
////					bi.add(docUri, propertyUri, objectUri);
////				}
////			}
////			bi.save();
////		} catch (Exception e) { throw new SLRuntimeException(e); }
////	}
//	try (JDocUpdate du = new JDocUpdate(this, doc)) {
//		du.addDocProperty(propertyUri, objectUris);
//	} catch (Exception e) { throw new SLRuntimeException(e); }
//}
//
//public void setDocProperty(SLDocument doc, String propertyUri, String propertyValue, String lang) {
////	propertyValue = safe(propertyValue);
////	lang = safe(lang);
////	String docUri = doc.getURI();
////	try {
////		if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) {
////			creationDateCase(doc, propertyValue);
////			return;
////		}
////		JFileBiModel bi = getJFileBiModel4DocsHandlingNewDocEvent(doc, propertyUri);
////		bi.set(docUri, propertyUri, propertyValue, lang);
////		bi.save();
////	} catch (Exception e) { throw new SLRuntimeException(e); }
//	try (JDocUpdate du = new JDocUpdate(this, doc)) {
//		du.setDocProperty(propertyUri, propertyValue, lang);
//	} catch (Exception e) { throw new SLRuntimeException(e); }
//}
//
//public void setDocProperty(SLDocument doc, String propertyUri, String objectUri) {
////	String docUri = doc.getURI();
////	try {
////		if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) throw new IllegalArgumentException("Impossible way to modify " + SLVocab.SL_CREATION_DATE_PROPERTY);
////		JFileBiModel bi = getJFileBiModel4DocsHandlingNewDocEvent(doc, propertyUri);
////		bi.set(docUri, propertyUri, objectUri);
////		bi.save();
////	} catch (Exception e) { throw new SLRuntimeException(e); }
//	try (JDocUpdate du = new JDocUpdate(this, doc)) {
//		du.setDocProperty(propertyUri, objectUri);
//	} catch (Exception e) { throw new SLRuntimeException(e); }
//}

//private void creationDateCase(SLDocument doc, String yyyy_mm_dd) throws JenaException, IOException, URISyntaxException {
//		if (existsAsSubject(doc)) {
//			// it's forbidden to change sl:creationDate
//			// -- except if its a local document ???
//			// (as we use its uri to locate it and its corresponding sl.rdf file) 
//			if (!this.isLocalDocument(doc.getURI())) throw new IllegalArgumentException("Impossible to modify " + SLVocab.SL_CREATION_DATE_PROPERTY);
//		}
//		String docUri = doc.getURI();
//		// we have to set the SL_CREATION_DATE first,
//		// in order to choose the right file to write new doc to
//		// (cf case where propertyUri is SL-CREATION_DATE: this happens with import from delicious:
//		// we want to set the creation date (which has to be the first prop to be set for the doc)
//		JenaUtils.add(this.docsModel, docUri, SL_CREATION_DATE_PROPERTY, yyyy_mm_dd, null);
//		// now it's ok to find the file where to save statement
//		JFileModel smallJFileModel = getJFileModel4Docs(docUri);
//		JenaUtils.add(smallJFileModel.getModel(), docUri, SL_CREATION_DATE_PROPERTY, yyyy_mm_dd, null);
//		// others things to do on newDocEvent:
//		JFileBiModel bi = new JFileBiModel(this.docsModel, smallJFileModel);
//		moreOnDocCreation(docUri, bi);
//		bi.save();
//}

//
//

/** Add a property to existing keyword. */
public void addKwProperty(String kwUri, String propertyUri, String objectUri) {
	if ((objectUri != null) && (!("".equals(objectUri)))) {
		try {
			JFileBiModel bi = getJFileBiModel4Kws(kwUri);
			bi.add(kwUri, propertyUri, objectUri);
			bi.save();
		} catch (Exception e) { throw new SLRuntimeException(e); }
	}
}
public void addKwProperty(String kwUri, String propertyUri, String[] objectUris) {
	try {
		JFileBiModel bi = getJFileBiModel4Kws(kwUri);
		for (int i = 0; i < objectUris.length; i++) {
			bi.add(kwUri, propertyUri, objectUris[i]);
		}
		bi.save();
	} catch (Exception e) { throw new SLRuntimeException(e); }
}
public void addKwProperty(String kwUri, String propertyUri, String propertyValue, String lang) {
	propertyValue = safe(propertyValue);
	lang = safe(lang);
	if ((propertyValue != null) && (!("".equals(propertyValue)))) {
		try {
			if (isLabelProperty(propertyUri)) {
				SLKeyword kw = getKeyword(kwUri);
				Locale locale = null;
				if ((lang == null) || ("".equals(lang))) {
					locale = Locale.getDefault();
				} else {
					locale = new Locale(lang);
				}
				// this.thesaurusIndex.addKw(kw, propertyValue, locale); // for ThesaurusIndexOK
				this.thesaurusIndex.addKw(kw, propertyValue, locale);
			}
			JFileBiModel bi = getJFileBiModel4Kws(kwUri);
			bi.add(kwUri, propertyUri, propertyValue, lang);
			bi.save();
		} catch (Exception e) { throw new SLRuntimeException(e); }
	}
}
/** fait un remove si propertyValue null ou ""*/
public void setKwProperty(String kwUri, String propertyUri, String objectUri) {
	if (objectUri != null) {
		if (isLabelProperty(propertyUri)) {
			throw new RuntimeException("Can't set " + propertyUri + " to value that is not a literal");
		}
	}
	try {
		JFileBiModel bi = getJFileBiModel4Kws(kwUri);
		bi.set(kwUri, propertyUri, objectUri);
		bi.save();
	} catch (Exception e) { throw new SLRuntimeException(e); }
}
/** fait un remove si propertyValue null ou "" */
public void setKwProperty(String kwUri, String propertyUri, String propertyValue, String lang) {
	propertyValue = safe(propertyValue);
	lang = safe(lang);
	boolean isLabelProperty = isLabelProperty(propertyUri);
	SLKeyword kw = null; // mis à non null si isLabelProperty
	try {
		if (isLabelProperty) {
			// we remove all the current labels for kws in index
			// (and add the new ones later below)
			kw = getKeyword(kwUri);
			this.thesaurusIndex.deleteKw(kw);
			/*Locale locale = null;
			if ((lang == null) || ("".equals(lang))) {
				locale = Locale.getDefault();
			} else {
				locale = new Locale(lang);
			}
			if () {
				this.thesaurusIndex.removeKwLabel(kw, propertyValue, locale);
			}*/
		}
		JFileBiModel bi = getJFileBiModel4Kws(kwUri);
		bi.set(kwUri, propertyUri, propertyValue, lang);
		bi.save();
		if (isLabelProperty) {
			// this.thesaurusIndex.addKw(kw); // for ThesaurusIndexOK
			this.thesaurusIndex.addKw(kw);
		}
	} catch (Exception e) { throw new SLRuntimeException(e); }
}

/** Retourne le JFileModel pertinent pour le document docUri. */
JFileModel getJFileModel4Docs(String docUri) throws JenaException, IOException, URISyntaxException {
	// DocsFile docsFile = doc2DocsFile(docUri);
	DocMetadataFile docMetadataFile = doc2DocMetadataFile(docUri);
	return new JFileModel(docMetadataFile.getFile().getAbsolutePath(), docMetadataFile.getBase());
}

/** Retourne le JFileBiModel pertinent pour le document docUri. */
JFileBiModel getJFileBiModel4Docs(String docUri) throws JenaException, IOException, URISyntaxException {
	JFileModel smallJFileModel = getJFileModel4Docs(docUri);
	return new JFileBiModel(this.docsModel, smallJFileModel);
}

private JFileBiModel getJFileBiModel4Kws(String kwUri) throws JenaException, IOException {
	// String kwsFile = getDefaultKwsFile();
	SLThesaurus th = kwUri2Thesaurus(kwUri);
	if (th == null) throw new IllegalArgumentException("No opened thesaurus for " + kwUri);
	JFileModel smallJFileModel = new JFileModel(th.getDefaultFile(), th.getBase());
	return new JFileBiModel(this.kwsModel, smallJFileModel);
}

/**
 * Attention, selon cette implémentation, vérifie juste s'il existe ds this.kwsModell un statement
 * au sujet de uri. Et donc, par ex, retourne true si kwUri est un alias
 */
public boolean kwExists(String kwUri) {
	Resource res = this.kwsModel.getResource(kwUri);
	StmtIterator ite = this.kwsModel.listStatements(res, (Property) null, (RDFNode) null);
	for (;ite.hasNext();) {
		ite.close();
		return true;
	}
	return false;
}


/** Le kw est censé ne pas exister.
 * @throws URISyntaxException */
protected void createKw(String uri, String label, Locale locale) throws JenaException, IOException, URISyntaxException {
	label = safe(label);
	JFileBiModel bi = getJFileBiModel4Kws(uri);
	String lang;
	if (locale == null) {
		lang = null;
	} else {
		lang = locale.getLanguage();
	}
	bi.newKeyword(uri, label, lang);
  YearMonthDay today = new YearMonthDay();
	bi.add(uri, SL_CREATION_DATE_PROPERTY, today.getDateString(), null);
	bi.add(uri, SL_CREATION_TIME_PROPERTY, today.getTimeString(), null);
	bi.save();
}

//
// SAVE
//

/**
 * Cette version écrit les kwsModel complet ds le fichier kws le + haut,
 * et pareil pour les docs

 * OLDER COMMENT :
 * Convient donc si on n'en ouvre qu'un.
 * quoique...
 * Situation typique : les kws définis ds d'autres fichiers, et
 * dont on a besoin pour qualifier les docs de ce fichier.
 * C'est OK si on utilise une String caractérisant le kw
 * C'est même OK qd les kws donnés par uri sont juste mentionnés (apparents comme HAS_KEYWORD_PR0PERTY d'un doc)
 * (argument pour 2 models distincts, dont un seulement KWS ? ala semanlink hc ? rq : oui, mais -> 2 fichiers
 * BTW, 2 fichiers, permet des choses en + pour les uri de KWs ? (rappel, ils doivent avoir une url longue
 * avec un "namespace" fixé, quand on n'a qu'un seul fichier) Je ne crois pas :
 * en effet, on doit pouvoir faire référence ? un kw ? partir de n'importe o?, ce qui implique qu'ils aient tous
 * la même "base" (du moins, qu'on la connaisse sans difficulté)
 * Par contre, avoir des fichiers "purs kws" reste possible et interessant :
 * Ils ne se situent pas forcément "? l'url des kws". Leur base est la base des kws. Donc, inutile
 * d'avoir les urls longues comme ds un model avec des docs.
 * La question est :
 * quand on ouvre un model de docs, comment savoir quels fichiers ouvrir pour avoir les kws
 * (cf import d'ontologies en DAML) Pourrait être "? coté", ds le même dossier (genre un fichier sl et slk)
 *
 * DESIGN DECISION :
 * favoriser la déf des Keywords dans des fichiers (et Model ?) qui leur sont exclusivement consacrés
 * (ressemble bigrement ? un fichier d'ontologie)
 *
 * VOIR :
 * la façon dont on définit la liste des kws ds un model : 2 aspects :
 * - les kws qui sont des HAS_KEYWORD_PR0PERTY d'un doc (pourraient être une simple String literal), ds un docset
 * - les entités définies avec un rdf:type KEYWORD, ds un "graph de kws" (ala old sl)
 * J'ai bien l'impression qu'on a besoin des 2
 * le 1er : liste des kws utilisés ds un docset
 *
 * RQ sur ce qui précède :
 * quand on crée un docset ? la main, le plus simple est souvent d'utiliser des littéraux comme kws
 * Ensuite, lors d'une utilisation, on établit le lien entre ces kws littéraux et des kws "référencés"
 * (ds un docset, cad une ontologie. On peut ensuite remplacer ds le fichier initial le litteral
 * par le KW de l'ontologie. (cf le network qui s'autoorganise, qui s'améliore)
 *
 *NE MARCHE PLUS : openKWsFiles ÉTAIT CONSTITUÉ DE STRING FILENME, MAINTENANT KwsFile
 */
/*public void save() throws JenaException, IOException {
	try {
		saveFilesByKind(this.openKWsFiles, true);
		saveFilesByKind(this.openDocsFiles, false);
	} catch (IOException e) {
		// TODO Auto-generated catch block
		throw e;
	} catch (Exception e) { throw new SLRuntimeException(e); }
}
private void saveFilesByKind(Vector openFiles, boolean itsConceptsSpace) throws JenaException, MalformedURLException, IOException, URISyntaxException {
  // JE TRIE openFiles par folder (mais en remplacant les fichiers par folder) pour
  // ne sauver que ceux de + haut niveau de hiérarchie.
  // Défaut : comme ça, je ne pourrais pas après remettre le nom court original
  // du fichier (obligé de supposer qu'ils s'appelent sldocs ou slkws)
  // pour trier
  String[] opFolders = new String[0];
  opFolders = (String[]) openFiles.toArray(opFolders);
  for (int i = 0;  i < opFolders.length; i++) { // je sors ? la fin de la 1ere iteration
    opFolders[i] = file2Folder(opFolders[i]);
  }
  Arrays.sort(opFolders);

  //for (Enumeration e = this.openFiles.elements(); e.hasMoreElements();) {
    //String slFile = (String) e.nextElement();
  String lastFile = null;
  for (int i = 0;  i < opFolders.length; i++) {
  	// String slFile = (String) e.nextElement();
  	String slFile = opFolders[i];
  	if (lastFile != null) {
  		if (slFile.startsWith(lastFile)) continue; // on ne sauve que les fichiers en haut de hiérarchie.
  	}
  	lastFile = slFile;
    Model model;
    if (itsConceptsSpace) {
    	model = this.kwsModel;
    } else {
    	model = this.docsModel;
    }
    save(model, slFile, itsConceptsSpace);
  } // for
} // saveFilesByKind

// 2003-08-12 // serait a revoir en particulier le save ds kws (base)
void save(Model model, String slFile, boolean itsConceptsSpace) throws JenaException, IOException, MalformedURLException, URISyntaxException {
    String shortSaveName;
    if (itsConceptsSpace) {
      shortSaveName = "slkws.rdf";
    } else {
      shortSaveName = "sl.rdf";
    }
    String saveFile = file2Folder(slFile) + shortSaveName;
    String base;
	if (itsConceptsSpace) {
		base = getDefaultThesaurus().getBase();
	} else {
		base =  filenameToUri(saveFile);
	}
	JenaUtils.writeModel(model, saveFile, base);
}
//
// SAVE AS
public void saveDocsModelAs(String fileName)  throws JenaException, MalformedURLException, IOException, URISyntaxException {
  Vector openFiles = new Vector();
  openFiles.add(fileName);
  saveFilesByKind( openFiles, false);
}
public void saveKWsModelAs(String fileName)  throws JenaException, MalformedURLException, IOException, URISyntaxException {
  Vector openFiles = new Vector();
  openFiles.add(fileName);
  saveFilesByKind( openFiles, true);
}

public void saveAs(String fileName) throws JenaException, MalformedURLException, IOException, URISyntaxException {
  saveKWsModelAs(fileName);
  saveDocsModelAs(fileName);
}
*/

//
// KWS COLLECTION RELATED
//

/** Met les JKeyword dans la collection passée en argument.
 *  Méthode d'interface.
 *  Cette implémentation ne met que les keywords effectivement utilisés pour marquer des documents du modèle
 *  (Resource ou littéraux), mais pas ceux qui ne sont que déclarés (ou qui ne font
 *  qu'intervenir comme parent ou child) */
public void kwsIntoCollection(Collection coll) throws JenaException, IOException {
  // Cette implémentation ne met que les keywords correspondant ? des
  // Resource de rdfs:Class JKeyword. Manque donc les littéraux.
  // kwsResIntoCollection(coll);
  // ou bien :
  // labelledResIntoCollection(coll);
  usedKWsIntoCollection(coll);
}

// 02/01/03
/** Met les JKeyword utilisés dans ce modèle dans la collection passée en argument.
 *  Contient tous les keywords utilisés pour marquer une resource dans ce modèle
 *  (cas des littéraux à voir //TODO) - mais aucun de ceux qui ne sont pas utilisés (même s'ils y sont définis)
 NE CREE PAS DES RES A LA PLACE DES LITTERAUX
 */
public void usedKWsIntoCollection(Collection coll) {
  Model model = this.docsModel;
  NodeIterator ite = model.listObjectsOfProperty(this.hasKeywordProperty);
  try {
	  for (;ite.hasNext();) {
	    RDFNode node = ite.nextNode();
	    coll.add(node2JKeyword((node)));
	  }
  } catch (Exception e) {
  	throw new SLRuntimeException(e);
  } finally {
	ite.close();
  }
}

/** attention, node doit être ds kwsModel */
private JKeyword node2JKeyword(RDFNode node) throws IOException {
	JKeyword kw;
	if (node instanceof Resource) {
	  kw = new JKeyword(this, (Resource) node);
	} else {
		// cas d'un JKeyword affecté au doc sous forme de simple litteral
		//JE NE SAIS PLUS FAIRE DEPUIS QUE plusierus vocab
		throw new SLRuntimeException("node2JKeyword : node n'est pas unr resource");
		/*
		// ceci, si on ne se préoccupe pas de créer des res pour les littéraux
		// kw = new JKeyword(this, getOrCreateKWRes(node.toString()));
		String kwLabel = null;
		String lang = null;
		if (node instanceof Literal) {
		  Literal lit = (Literal) node;
		  kwLabel = lit.getString();
		  lang = lit.getLanguage();
		} else {
		  kwLabel = node.toString();
		}
		String kwUri = this.kwLabel2UriCreatingKwIfNecessary(kwLabel, lang);
		kw = new JKeyword(this, this.kwsModel.createResource(kwUri));
		*/
	}
	return kw;
}

/** Met les JKeyword correspondant aux Resource de rdfs:Class JKeyword
 *  dans la collection passée en argument.
 *  (Ne prend donc pas en compte les littéraux.)
 *  ne sert pas si on ne met plus la classe rdfs:Class JKeyword, opération
 *  inutile si tous les kws et slt eux sont ds this.kwsModel
 */
public void kwsResIntoCollection(Collection coll) throws JenaException {
  Model model = this.kwsModel;
  ResIterator ite = model.listSubjectsWithProperty(RDF.type,this.keywordClass);
  SLJenaUtils.keywordIteratorIntoCollection(ite, coll, this);
}

///** Ajoute à une Collection les JKeyword créés à partir des resources affectées d'un rdfs:label -
// *  ce qui, au 5 décembre 2001, peut servir à caractériser les keywords (autres que littéraux).
// */
//void labelledResIntoCollection(Collection coll) throws JenaException {
//  Model model = this.kwsModel;
//  ResIterator ite = model.listSubjectsWithProperty(model.createProperty(SLVocab.PREF_LABEL_PROPERTY));
//  SLJenaUtils.keywordIteratorIntoCollection(ite, coll, this);
//}

//
// KWS RELATED
//

// Comportement si la res n'est pas de ce modèle ?
// on cherche ds le modèle de la resource,
// ou dans this ? Pourrait-on chercher (et trouver) ds this,
// même si la res n'en est pas ? (revoir ce qu'ils disent sur l'égalité de resources)
// A VOIR

// COMMENTAIRE DEPASSE :
// REMARQUE : ça ne marche pas exactement de la même façon pour les keywords
// et les documents : pour les keywords, on crée ici des JKeyword,
// alors que pour les documents, non : la List retournée contient simplement des
// Resources.
// Ceci parce que a priori, l'url d'un document me sembalit suffire pour faire ce qu'on veut en faire
// (l'ouvrir)
// Et qu'il est encore temps de créer le document + tard (et ça se passe
// dans le listmodel - on a alors besoin d'un objet de classe JDocument
// pour ne pas être contraint au toString qu'utilise la JList pour displayer
// les élts du ListModel.
// Dans un cas donc, on crée tous les objets de classe JKeyword au départ.
// Dans l'autre, on ne les crée peut-être pas tous (pas sÃ»r d'ailleurs), et potentiellemnt,
// on risque de créer plusieurs fois le même. ??? A VOIR

// de plus, il va faloir créer un ListModel différent pour la liste de documents

/** retourne une ArrayList de JKeyword.
 *  Mettre cette méthode dans la classe JKeyword ?
 */
public ArrayList getParentsList(Resource kwRes) throws JenaException {
  StmtIterator stmtIt = kwRes.listProperties(this.hasParentProperty);
  ArrayList x = new ArrayList();
  for (;stmtIt.hasNext();) {
		Statement sta = stmtIt.nextStatement();
		x.add(new JKeyword(this, (Resource) sta.getObject()));
  }
  Collections.sort(x);
  return x;
}

/** friend is symetric. This is handled here */
public List getFriendsList(Resource kwRes) throws JenaException {
  HashSet hs = new HashSet();
  StmtIterator stmtIt = kwRes.listProperties(this.hasFriendProperty);
  for (;stmtIt.hasNext();) {
		Statement sta = stmtIt.nextStatement();
		hs.add(sta.getObject());
  }
  stmtIt = this.kwsModel.listStatements(null, this.hasFriendProperty, kwRes);
  for (;stmtIt.hasNext();) {
		Statement sta = stmtIt.nextStatement();
		hs.add(sta.getSubject());
  }
  ArrayList x = new ArrayList(hs.size());
  Iterator it = hs.iterator();
  for(;it.hasNext();) {
  	x.add(new JKeyword(this, (Resource) it.next()));
  }
  
  Collections.sort(x);
  return x;
}

/** retourne une ArrayList de JKeyword.
 *  Mettre cette méthode dans la classe JKeyword ?
 */
public ArrayList getChildrenList(Resource kwRes) throws JenaException {
  Model model = this.kwsModel;
  // ResIterator ite = kwRes.getModel().listSubjectsWithProperty(HAS_PARENT_PROPERTY, kwRes);
  ResIterator ite = model.listSubjectsWithProperty(this.hasParentProperty, kwRes);
  ArrayList x = new ArrayList();
  for (;ite.hasNext();) {
	x.add(new JKeyword(this, ite.nextResource()));
  }
  ite.close();
  Collections.sort(x);
  return x;
}

public boolean hasChild(Resource kwRes) throws JenaException {
	  Model model = this.kwsModel;
	  ResIterator ite = model.listSubjectsWithProperty(this.hasParentProperty, kwRes);
	  if (ite.hasNext()) {
	  	ite.close();
	  	return true;
	  }
	  return false;
}


public boolean hasDocument(Resource kwRes) {
	  Model model = this.docsModel;
	  ResIterator ite = model.listSubjectsWithProperty(this.hasKeywordProperty, kwRes);
	  if (ite.hasNext()) {
	  	ite.close();
	  	return true;
	  }
	  return false;
}

/** Retourne une ArrayList de Documents affectés d'un certain keyword.
 *  ATTENTION, si des documents sont simplement affectés du label correspondant au keyword,
 *  ils ne seront pas retournés.
 */
public ArrayList<SLDocument> getDocumentsList(Resource kwRes) throws JenaException {
  Model model = this.docsModel;
  // ResIterator ite = kwRes.getModel().listSubjectsWithProperty(this.hasKeywordProperty, kwRes);
  ResIterator ite = model.listSubjectsWithProperty(this.hasKeywordProperty, kwRes);
  ArrayList<SLDocument> x = new ArrayList<SLDocument>();
  for (;ite.hasNext();) {
  		x.add(new JDocument(this, ite.nextResource()));
  }
  return x;
}

// 02/01/08
/** Ajoute ? une Collection les Documents afectés d'un certain keyword -
 *  y compris si ce n'est que sous forme littérale.
 */
public ArrayList<SLDocument> getDocumentsList(JKeyword kw) throws JenaException {
  // Ceux affectés du kw ? proprement parler
  ArrayList<SLDocument> x = getDocumentsList(kw.getRes());
  // Les littéraux
  // pour trouver aussi ceux qui ne sont qu'affectés du littéral
  // 2003-08 : bof bof ?
  Model model = this.docsModel;
  ResIterator ite = model.listSubjectsWithProperty(this.hasKeywordProperty, kw.getLabel());
  for (;ite.hasNext();) {
	x.add(new JDocument(this, ite.nextResource()));
  }
  return x;
}

//
// CREATION D'UN DOCUMENT
//
//
// KWS D'UN DOC RELATED
//

/** retourne une ArrayList des JKeyword d'un doc */
public ArrayList<SLKeyword> getKeywordsList(String uri) {
   Model model = this.docsModel;
   Resource res = model.getResource(uri);
    if (res == null) return new ArrayList<SLKeyword>(); // ?
    return getKeywordsList(res);
}

/**
 *  retourne une ArrayList des JKeyword d'un doc
 *  NE Traite PLUS le cas des litteraux depuis qu'on a plusieurs vocab
 */
 // 02/01/06
ArrayList<SLKeyword> getKeywordsList(Resource doc) {
  Model model = this.docsModel;
  // ON FERAIT MIEUX D'UTILISER public NodeIterator listObjectsOfProperty(Resource s, Property p)

  // 02/01/03 : traitement du cas des keywords donnés dans un fichier sous forme de Literal
  // System.out.println("getKeywordsList of " + doc);
  NodeIterator ite = model.listObjectsOfProperty(doc, this.hasKeywordProperty);
  ArrayList<SLKeyword> x = new ArrayList<SLKeyword>();
	try {
	    for (; ite.hasNext();) {
	    	// 2007-04 : pas bon, parce que ite.nextNode() ds docsModel, pas kwsModel
	    	// Pourtant, tout avait l'air de bien marcher.
	    	// Sauf pour exporter
	    	// x.add(node2JKeyword((ite.nextNode())));
	    	Resource res = (Resource) ite.nextNode();
	    	res = this.kwsModel.getResource(res.getURI());
	    	x.add(new JKeyword(this, res));
	    }
	} catch (Exception e) {
		throw new SLRuntimeException(e);
	} finally {
		ite.close();
	}
  Collections.sort(x);
  return x;
}

//
//
//

/** Detruit un keyword. */
public void delete(SLKeyword kw) {
	try {
		getThesaurusIndex().deleteKw(kw);
		
		String kwUri = kw.getURI();
		JFileBiModel bi = getJFileBiModel4Kws(kwUri);
		bi.delete(kwUri);
		bi.save();
		
		List al = kw.getDocuments();
		for (int i = 0; i < al.size() ; i++) {
			//FACILE A OPTIMISER -- ah bon ? // TODO
			SLDocument doc = (SLDocument) al.get(i);
			JFileBiModel bi2 = this.getJFileBiModel4Docs(doc.getURI());
			bi2.delete(kwUri);
			bi2.save();
		}
	} catch (Exception e) { throw new SLRuntimeException(e); }	
}

public void delete(SLDocument doc) {
	// si on gère explcitement l'écriture des fichiers modifiés :
	try {
		String docUri = doc.getURI();
		JFileBiModel bi = getJFileBiModel4Docs(docUri);
		bi.delete(docUri);
		bi.save();
	} catch (Exception e) { throw new SLRuntimeException(e); }
	// si on laisse gérer l'écriture des modifs par le listener :
	
	// marche pas bien
	// besoin de patcher pas d'ecriture de la suppression de la date de creation
	// (à mon avis c'est pire que ça : tous les statements virés après la date de creation
	// ne sont pas sauvés)
	/*
	try {
		String docUri = doc.getURI();
		JenaUtils.delete(this.docsModel, docUri);
	} catch (Exception e) { throw new SLRuntimeException(e); }	
	*/
	
	/*try {
		// patch pas d'ecriture de la suppression de la date de creation
		String docUri = doc.getURI();
		// JFileBiModel bi = getJFileBiModel4Docs(docUri);
		JenaUtils.delete(this.docsModel, docUri);
		// bi.save(); ////////////////// ????????????????????
	} catch (Exception e) { throw new SLRuntimeException(e); }	*/
	
}


//
// METADATA EXTRACTION
//

public void onNewDoc(SLDocument doc) throws IOException, URISyntaxException {
	try {
		MetadataExtractorManager ex = getMetadataExtractorManager();
		if (ex != null) {
			ex.doIt(doc, this);
		}
	} catch (Throwable e) { // on ne veut pas planter
		System.err.println("Error extracting metadata for " + doc.getURI() + " : " + e.getMessage());
		e.printStackTrace();
	}
}

//
//
//

public long size() { return this.kwsModel.size() + this.docsModel.size(); }
public long kwsSize() { return this.kwsModel.size(); }
public long docsSize() { return this.docsModel.size(); }

//
// RECHERCHE RES AFFECTEES D'UNE PROPRIETE DE VALEUR DONNEE
//

/** Retourne une ArrayList de Documents affectés d'une certaine ppté. 
 *  (supporte null ds propertyUri via getDocumentsList2)
 *  @see getDocumentsList(Resource)
 */
public ArrayList getDocumentsList(String propertyUri, String objectUri) throws JenaException {
	Model model = this.docsModel;
	if (propertyUri == null) return getDocumentsList2(null, objectUri);
	Property prop = this.docsModel.getProperty(propertyUri);
	Resource obj = this.docsModel.getResource(objectUri);
	ResIterator ite = model.listSubjectsWithProperty(prop, obj);
	ArrayList x = new ArrayList();
	for (;ite.hasNext();) {
		x.add(new JDocument(this, ite.nextResource()));
	}
	ite.close();
	return x;
}

public ArrayList getDocumentsList(String propertyUri, String propertyValue, String lang) throws JenaException {
	Model model = this.docsModel;
	Property prop = this.docsModel.getProperty(propertyUri);
	ResIterator ite = model.listSubjectsWithProperty(prop, model.createLiteral(propertyValue, lang));
	ArrayList x = new ArrayList();
	for (;ite.hasNext();) {
		x.add(new JDocument(this, ite.nextResource()));
	}
	ite.close();
	return x;
}

// fait pour trouver la source d'un doc (avec inverse = true)
// propertyUri probableemnt pas supporté si inverse = true
public ArrayList getDocumentsList(String propertyUri, String uri, boolean inverse) throws JenaException {
	if (!inverse) return getDocumentsList(propertyUri, uri);
	Model model = this.docsModel;
	if (propertyUri == null) return getDocumentsList2(null, uri);
	Property prop = this.docsModel.getProperty(propertyUri);
	Resource subj = this.docsModel.getResource(uri);
	NodeIterator ite = model.listObjectsOfProperty(subj,prop);
	ArrayList x = new ArrayList();
	for (;ite.hasNext();) {
		Object o = (ite.next());
		if (o instanceof Resource) {
			x.add(new JDocument(this, (Resource) o));
		}
	}
	ite.close();
	return x;
}

// 2008/02
/** inside kwsModel */
public ArrayList getKeywordsList(String propertyUri, String objectUri) throws Exception {
	Model model = this.kwsModel;
	if (propertyUri == null) throw new RuntimeException("doesn't support null prop");
	Property prop = this.kwsModel.getProperty(propertyUri);
	Resource obj = this.kwsModel.getResource(objectUri);
	ResIterator ite = model.listSubjectsWithProperty(prop, obj);
	ArrayList x = new ArrayList();
	for (;ite.hasNext();) {
		x.add(new JKeyword(this, ite.nextResource()));
	}
	ite.close();
	return x;
	
}
//2008/02
/** inside kwsModel */
public ArrayList getKeywordsList(String propertyUri, String propertyValue, String lang) throws Exception {
	Model model = this.kwsModel;
	Property prop = this.kwsModel.getProperty(propertyUri);
	ResIterator ite = model.listSubjectsWithProperty(prop, model.createLiteral(propertyValue, lang));
	ArrayList x = new ArrayList();
	for (;ite.hasNext();) {
		x.add(new JKeyword(this, ite.nextResource()));
	}
	ite.close();
	return x;
}


/**
 * Retourne une ArrayList de Documents affectés d'une certaine ppté.
 * idem getDocumentsList, mais supporte null ds propertyUri.
 * Ex d'utilisation : pour la gestion des copies locales d'uri http.
 * On enregistre la copie locale dont on documente la source.
 * Sur la page de l'uri http, on veut avoir accés à la copie locale, cad
 * le doc qui a sa ppté "source" valant cette uri http. Appeler cette méthode
 * avec propertyUri valant "source" et objectUri valant l'uri http
 * (Pourquoi ne pas avoir affecté à l'uri http une ppté "hasLocalCopy" ?
 * parce qu'on serait géné pour lui donner sa valeur : uri file, on ne pourrait plus bouger le fichier.
 * Ceci dit, si le fichier a été mis sur cédé et n'est pas accessible, on ne saura même pas qu'il existe)
 * @param propertyUri peut être null
 * @param objectUri
 */
public ArrayList getDocumentsList2(String propertyUri, String objectUri) throws JenaException {
	Model model = this.docsModel;
	Property prop = null;
	if (propertyUri != null) prop = this.docsModel.getProperty(propertyUri);
	Resource obj = this.docsModel.getResource(objectUri);
	StmtIterator ite = model.listStatements(null, prop, obj);
	ArrayList x = new ArrayList();
	for (;ite.hasNext();) {
		Statement sta = ite.nextStatement();
		x.add(new JDocument(this, sta.getSubject()));
	}
	ite.close();
	return x;
}

//
// FAIRE QUELQUE CHOSE SUR TOUS LES FICHIERS
//

/** to be completed to do something */
void doWithAllFiles() {
	//List v = this.openDocsFiles;
	List v = this.openKWsFiles;
	for (int i = 0; i < v.size(); i++) {
		KwsFile f = (KwsFile) v.get(i);
		Model mod = ModelFactory.createDefaultModel();
		try {
			ModelFileIOManager.getInstance().readModel(mod, f.getFilename(), f.getBase());
		} catch (Exception e) { throw new SLRuntimeException(e); }
	}
}

//
// CORRECTION DES URIS DE KWS
// (CAS DU CHANGEMENT DE FACON DE CALCULER L'URI A PARTIR DU LIBELLE)
// 
//

/** Attention, ceci ne recharge pas le model avec les nlles valeurs :
 * si on l'utilise, il faut donc juste après quitter l'appli et la relancer
 * (ou bien recharger tous les fichiers)
 */

public boolean correctOldKwUris() throws Exception {
	boolean hasChanged = false;
	ModelCorrector corrector = oldKwUrisCorrector();
	List v = this.openKWsFiles;
	for (int i = 0; i < v.size(); i++) {
		KwsFile f = (KwsFile) v.get(i);
		boolean changed = corrector.correctKwsModel(f.getFilename(), f.getBase());
		hasChanged = changed || hasChanged;
	}
	v = this.openDocsFiles;
	for (int i = 0; i < v.size(); i++) {
		DocsFile f = (DocsFile) v.get(i);
		boolean changed = corrector.correctDocsModel(f.getFilename(), f.getBase());
		hasChanged = changed || hasChanged;
	}
	return hasChanged;
}

ModelCorrector oldKwUrisCorrector() {
	ModelCorrector corrector = new ModelCorrector();
	KeywordUriCorrection.recomputeAllKwUrisFromLabel(corrector, this);
	return corrector;
}


/** Attention, ceci ne recharge pas le model avec les nlles valeurs :
 * si on l'utilise, il faut donc juste après quitter l'appli et la relancer
 * (ou bien recharger tous les fichiers)
 */

//public boolean correctAlias() throws Exception {
//	boolean hasChanged = false;
//	StmtIterator sit = kwsModel.listStatements((Resource) null, SLSchema.hasAlias, (Resource) null);
//	List<Statement> aliasStatements = sit.toList();
//	ModelCorrector corrector = new ModelCorrector();
//	corrector.add(new AliasCorrection(aliasStatements));
//	
//	
//	List v = this.openDocsFiles;
//	for (int i = 0; i < v.size(); i++) {
//		DocsFile f = (DocsFile) v.get(i);
//		boolean changed = corrector.correctDocsModel(f.getFilename(), f.getBase());
//		hasChanged = changed || hasChanged;
//	}
//	return hasChanged;
//}

// pour retrouver les alais (déjà supprimé remplacé par altlbale), mais dont uri utilisée ds des docs
public boolean correctAliasFromAltLabel() throws Exception {
	boolean hasChanged = false;
	StmtIterator sit = kwsModel.listStatements((Resource) null, SKOS.altLabel, (Resource) null);
	List<Statement> aliasStatements = new ArrayList<Statement>();
	for(;sit.hasNext();) {
		Statement sta = sit.next();
		String s = ((Literal) sta.getObject()).getString();
		String aliasUri = kwLabel2UriQuick(s, this.getDefaultThesaurus().getURI(), Locale.getDefault());
		aliasStatements.add(kwsModel.createStatement(sta.getSubject(), hasAliasProperty, kwsModel.createResource(aliasUri)));
	}
	ModelCorrector corrector = new ModelCorrector();
	corrector.add(new AliasCorrection(aliasStatements));
	
	
	List v = this.openDocsFiles;
	for (int i = 0; i < v.size(); i++) {
		DocsFile f = (DocsFile) v.get(i);
		boolean changed = corrector.correctDocsModel(f.getFilename(), f.getBase());
		hasChanged = changed || hasChanged;
	}
	return hasChanged;
}








/*
private void addOldKwUrisCorrector(ModelCorrector corrector) { //
	List kwList = this.getKWsInConceptsSpaceArrayList();
	for (int i = 0; i < kwList.size(); i++) {
		SLKeyword kw = (SLKeyword) kwList.get(i);
		addOldKwUrisCorrector(corrector, kw);
	}
	// restent les alias
	kwList = new ArrayList();
	aliasesIntoCollectionOfUris(kwList);
	for (int i = 0; i < kwList.size(); i++) {
		String aliasUri = (String) kwList.get(i);
		SLKeyword kw = this.getKeyword(aliasUri);
		addOldKwUrisCorrector(corrector, kw);
	}
	
}
private void addOldKwUrisCorrector(ModelCorrector corrector, SLKeyword kw) {
	Locale locale = Locale.getDefault();
	String lib = kw.getLabel();
	String newShortUri = kwLabel2ShortUri(lib,locale); // pour bien faire, faudrait prendre la langue du label, s'il y en a une
	String oldUri = kw.getURI();
	// int k = oldUri.indexOf("#");
	int k = oldUri.lastIndexOf("/");
	if (k < 0) {
		System.err.println("uri zarbi : " + oldUri);
		return;
	}
	String oldShortUri = oldUri.substring(k+1);
	if (!oldShortUri.equals(newShortUri)) {
		// String newUri = oldUri.substring(0,k) + "#" + newShortUri;
		String newUri = oldUri.substring(0,k) + "/" + newShortUri;
		System.out.println(oldUri + " : " + newUri);
		KeywordUriCorrection correction = new KeywordUriCorrection(oldUri, newUri);
		corrector.add(correction);
	}	
}

*/







/** nb de docs. Achtung, lourding */
public long numberOfDocs() {
	long x = 0;
	ResIterator ite = this.docsModel.listSubjectsWithProperty(this.hasKeywordProperty);
	for (;ite.hasNext();) {
		ite.next();
		x++;
	}
	return x;
}

//
//
//

public void removeKWStatement(String kwUri, String propUri, String objUri) {
	try {
		JFileBiModel bi = getJFileBiModel4Kws(kwUri);
		bi.remove(kwUri, propUri, objUri);
		bi.save();
	} catch (Exception e) { throw new SLRuntimeException(e); }	
}

//
//
//

// 2008/02 

/*public SLKeyword homePage2Tag(String homePageUri) {
	Property homePageProp = kwsModel.createProperty(SL_HOME_PAGE_PROPERTY); // todo optim
	ResIterator it = kwsModel.listSubjectsWithProperty(homePageProp, kwsModel.createResource(homePageUri));
	SLKeyword x = null;
	for (;it.hasNext();) {
		x = new JKeyword(this, it.nextResource());
		break;
	}
	it.close();
	return x;
}*/

/** Search tag such as <tag,propUri,objectUri> */
public SLKeyword object2Tag(String propUri, String objectUri) {
	Property homePageProp = kwsModel.createProperty(propUri);
	ResIterator it = kwsModel.listSubjectsWithProperty(homePageProp, kwsModel.createResource(objectUri));
	SLKeyword x = null;
	for (;it.hasNext();) {
		x = new JKeyword(this, it.nextResource());
		break;
	}
	it.close();
	return x;
}

/** list of rdf:type used for tags. */ // TODO OPTIM: don't compute each time. See where it can change: rdf:type form in edit keywords
public Iterator rdfTypes4Tags() {
	return this.kwsModel.listObjectsOfProperty(RDF.type);
}


//
// uris for bookmarks TODO
//

@Override
// ATTENTION, partiel, jamais utilisé, et chercher ATTENTION dans le code
public SLDocument convertOld2NewBookmark(String onlineUri) throws Exception {
	
	SLDocument docToDisplay = null;
	SLDocument bookmark2019 = bookmarkUrl2Doc(onlineUri);
	if (bookmark2019 != null) {	
		docToDisplay = bookmark2019;
		return docToDisplay;
	}
	
	// onlineUri n'existe pas en tant que "nouveau bookmark"
	SLDocument docOnline = smarterGetDocument(onlineUri);
	if (!(existsAsSubject(docOnline))) {
		throw new RuntimeException("that doc doesn't exist");
	}
	
	// onlineUri URI d'un doc bookmarké de l'ancienne manière
	
	// il faut :
	// - récupérer tous les statements le concernant
	// - les virer de là où ils sont écrits
	// 		- où est-ce ? là où on sauverait les choses ds une modif du doc tel qu'il est
	// - créer le nouveau bookmark, y ajouter les statements qui vont bien
	// 		- attention à la date de création à conserver
	// 		- attention à l'éventuelle copie locale
	// sauver tout ça
	
	// 
	
	// a new model where we'll store the statements about the new bookmark
	Model m = ModelFactory.createDefaultModel();
	
	// creation of the "new bookmark" res
	// which URI? created from the title, if any
	String title = SLUtils.getLabel(docOnline);
	SLDocument newBookmark = new NewBookmarkCreationData(this, title).getSLDocument(); // ATTENTION NE MARCHE QUE POUR UNE RES EXTERNE
	Resource newBookmarkRes = m.createResource(newBookmark.getURI());
	
	Resource resOnline = this.docsModel.getResource(onlineUri);
	
	// move all statements about resOnline to m, replacing resOnline by newBookmarkRes
	StmtIterator it = this.docsModel.listStatements (resOnline, (Property) null, (RDFNode) null);
	for(;it.hasNext();) {
		Statement s = it.next();
		m.add(newBookmarkRes, s.getPredicate(), s.getObject());
	}
	
	// statements with resOnline as object: not so clear what to do:
	// - source de copie locales
	// removeStats(mod, mod.listStatements (resOnline, (Property) null, (RDFNode) null));

	StmtIterator it2 = this.docsModel.listStatements ((Resource) null, (Property) null, resOnline);

	
	/*
	 * public SLDocument getDocument(String uri) {
	Resource res = this.docsModel.getResource(uri);
	return new JDocument(this, res);
}

	JFileModel smallJFileModel = getJFileModel4Docs(doc.getURI());
	JFileBiModel bi = new JFileBiModel(this.docsModel, smallJFileModel);
	*/
	
	
	return null;
}

public List<SLDocument> mainDocOf(Resource mainDocRes) {
  Model model = this.docsModel;
  ResIterator ite = model.listSubjectsWithProperty(this.mainDocProperty, mainDocRes);
  ArrayList<SLDocument> x = new ArrayList<>();
  for (;ite.hasNext();) {
  	x.add(new JDocument(this, ite.nextResource()));
  }
  ite.close();
  return x;

}

//
// 2020)03
//

// changing several props of a doc, saving only once

@Override public SLDocUpdate newSLDocUpdate(SLDocument doc) {
	return new JDocUpdate(this, doc);
}


class JDocUpdate extends SLDocUpdate {
	JModel mod;
	SLDocument doc;
	JFileBiModel bi;
	JDocUpdate(JModel mod, SLDocument doc) {
		this.mod = mod;
		this.doc = doc;
		String docUri = doc.getURI();
		try {
			bi = mod.getJFileBiModel4Docs(docUri);
		} catch (Exception e) { throw new RuntimeException(e) ; }
	}

	@Override
	public void close() throws JenaException, IOException, URISyntaxException {
		
		//
		// Handling of the SL_CREATION_DATE_PROPERTY
		//
		
		// if it's a new doc, add creation date and time
		// unless...
		boolean addCreationDate;
		if (!hasSLCreationDate(doc)) {
			// first,
			// if this is a destruction (no more statement about doc): 
			// we don't want to add a creation date!
			// second, 
			// we don't want something that is just a local copy of a doc to be considered a doc (with properties such as
			// creation date etc.), hence the following trick	
			Resource res = ((JDocument) doc).getRes();
			int nbSta = 0;
			StmtIterator ite = res.listProperties ();
			for (;ite.hasNext();) {
				nbSta++;
				if (nbSta > 1) {
					break;
				}
				ite.next();
			}
			ite.close();
			if (nbSta == 0) {
				addCreationDate = false;
						
			} else if (nbSta == 1) {
				// one one statement. Is this only statement involving SLVocab.SOURCE_PROPERTY?
				ite = res.listProperties(sourceProperty);
				boolean justALocalCopy = (ite.hasNext());
				ite.close();
				// only one statement, and it is SLVocab.SOURCE_PROPERTY
				if (justALocalCopy) {
					addCreationDate = false;
				} else {
					addCreationDate = true;
				}
				
			} else {
				addCreationDate = true;
			}
		} else {
			addCreationDate = false;
		}
			
		if (addCreationDate) {
			newDocEvent();
		}
		
		//
		//
		//
		
		bi.save();
	}
	
	private void newDocEvent() throws IOException, URISyntaxException {
		// it's better to set the SL_CREATION_DATE first,
		// in order to choose the right file to write new doc to
		// (cf case where propertyUri is SL-CREATION_DATE: this happens with import from delicious:
		// we want to set the creation date (which has to be the first prop to be set for the doc)
		String today = (new YearMonthDay()).getYearMonthDay("-");
		addDocProperty(SL_CREATION_DATE_PROPERTY, today, null);

		//autres trucs à faire au on new doc (à part la sl creation date). 
		addDocProperty(SL_CREATION_TIME_PROPERTY,(new YearMonthDay()).getTimeString(), null);
		if (SLVocab.DATE_PARUTION_PROPERTY.equals(SLServlet.getDefaultSortProperty())) { // 2019-09 for sicg
			addDocProperty(DATE_PARUTION_PROPERTY, today, null);		
		} else {
			//
			File file = getFile(doc.getURI());
			YearMonthDay modifDay = null;
			if (file != null) {
				if (file.exists()) {
					long lastModified = file.lastModified();
					// peut s'optimiser en testant sur la date plutôt que sa représentation en string
					modifDay = new YearMonthDay(new Date(lastModified));
					String modifVal = modifDay.getYearMonthDay("-");
					// if (modifVal.compareTo("2005-11-01") > 0) {
					addDocProperty(DATE_PARUTION_PROPERTY, modifVal, null); // 2020-03 TODO CHECK
					// }
				}
			}
		}
	}

	@Override
	public void addDocProperty(String propertyUri, String propertyValue, String lang) {
		propertyValue = safe(propertyValue);
		lang = safe(lang);
		String docUri = doc.getURI();
		if ((propertyValue != null) && (!("".equals(propertyValue)))) {
			try {			
//				if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) {
//					creationDateCase(propertyValue);
//					return;
//				}
				bi.add(docUri, propertyUri, propertyValue, lang);
			} catch (Exception e) { throw new SLRuntimeException(e); }
		}
	}

	@Override
	public void addDocProperty(String propertyUri, String objectUri) {
		String docUri = doc.getURI();
		if ((objectUri != null) && (!("".equals(objectUri)))) {
			if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) throw new IllegalArgumentException("Impossible to modify to such a thing " + SLVocab.SL_CREATION_DATE_PROPERTY);
			bi.add(docUri, propertyUri, objectUri);
		}
	}

	@Override
	public void addDocProperty(String propertyUri, String[] objectUris) {
		String docUri = doc.getURI();
		if (objectUris != null) {
			if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) throw new IllegalArgumentException("Impossible to modify to such a thing" + SLVocab.SL_CREATION_DATE_PROPERTY);
			for (int i = 0; i < objectUris.length;i++) {
				String objectUri = objectUris[i];
				if ((objectUri != null) && (!("".equals(objectUri)))) {
					bi.add(docUri, propertyUri, objectUri);
				}
			}
		}
	}

	@Override
	public void setDocProperty(String propertyUri, String objectUri) {
		if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) throw new IllegalArgumentException("Impossible to modify to such a thing" + SLVocab.SL_CREATION_DATE_PROPERTY);
		bi.set(doc.getURI(), propertyUri, objectUri);
	}
	
	@Override
	public void setDocProperty(String propertyUri, String propertyValue, String lang) {
		propertyValue = safe(propertyValue);
		lang = safe(lang);
		try {
//			if (SLVocab.SL_CREATION_DATE_PROPERTY.equals(propertyUri)) {
//				creationDateCase(propertyValue);
//				return;
//			}
			bi.set(doc.getURI(), propertyUri, propertyValue, lang);
		} catch (Exception e) { throw new SLRuntimeException(e); }
	}

	// 2020-03 
//	private void creationDateCase(String yyyy_mm_dd) throws JenaException, IOException, URISyntaxException {
//		if (existsAsSubject(doc)) {
//			// it's forbidden to change sl:creationDate
//			// -- except if its a local document ???
//			// (as we use its uri to locate it and its corresponding sl.rdf file) 
//			if (!isLocalDocument(doc.getURI())) throw new IllegalArgumentException("Impossible to modify " + SLVocab.SL_CREATION_DATE_PROPERTY);
//		}
//		String docUri = doc.getURI();
//		// we have to set the SL_CREATION_DATE first,
//		// in order to choose the right file to write new doc to
//		// (cf case where propertyUri is SL-CREATION_DATE: this happens with import from delicious:
//		// we want to set the creation date (which has to be the first prop to be set for the doc)
//		JenaUtils.add(mod.getDocsModel(), docUri, SL_CREATION_DATE_PROPERTY, yyyy_mm_dd, null);
//		// now it's ok to find the file where to save statement
//		JFileModel smallJFileModel = getJFileModel4Docs(docUri);
//		JenaUtils.add(smallJFileModel.getModel(), docUri, SL_CREATION_DATE_PROPERTY, yyyy_mm_dd, null);
//		// others things to do on newDocEvent:
//		bi = new JFileBiModel(mod.getDocsModel(), smallJFileModel);
//		moreOnDocCreation(docUri, bi);
//	}
}

} // class JModel
